import { asActiveConsumer } from "./reactive/activeConsumer.ts";
import { Computed } from "./reactive/computed.ts";
import { Constant } from "./reactive/constant.ts";
import { Effect, EffectQueues } from "./reactive/effect.ts";
import { State } from "./reactive/state.ts";
import type { ReadonlySignal, WritableSignal } from "./reactive/types.ts";

/**
 * Creates a {@link WritableSignal} to wrap the provided `value`.
 *
 * @param value the initial value of the `Signal` object.
 * @param equals (optional) a function for comparing new and old values of this
 *        `Signal`
 *
 * @returns `WritableSignal<T>`
 */
export function state<T>(
    value: T,
    equals?: (a: T, b: T) => boolean,
): WritableSignal<T> {
    return new State(value, equals);
}

/**
 * Creates a {@link ReadonlySignal}, whose value is generated by the provided
 * `compute` function.
 *
 * @param compute a function to generate the `Signal`'s value
 * @param equals (optional) a function for comparing new and old values of this
 *        `Signal`
 *
 * @returns `ReadonlySignal<T>`
 */
export function computed<T>(
    compute: () => T,
    equals?: (a: T, b: T) => boolean,
): ReadonlySignal<T> {
    return new Computed(compute, equals);
}

/**
 * Creates a simple wrapper around a `value` that implements the `ReadonlySignal`
 * interface. (For cases where a Signal is desired to match an existing
 * interface, but the overhead of an actual signal is undesirable.)
 *
 * NOTE: the details of TypeScript mean that it is sometimes possible to mutate
 * an object in ways that are not obvious from it's interface. Values provided
 * to this function MUST NOT be mutated, as changes to the provided value
 * will NOT be handled reactively.
 *
 * @returns `ReadonlySignal<Readonly<T>>`
 */
export function constant<T>(
    value: Readonly<T>,
): ReadonlySignal<Readonly<T>> {
    return new Constant(value);
}

/**
 * A schedulable side-effect that depends on up-to-date {@link Signal} values.
 *
 * @param fn a side-effect computation that depends on {@link Signal}s.
 * @param namespace an optional identifier for a unique queue to
 *  associate the returned {@link Effect} with ({@default ""})
 *
 * @returns `Effect`
 */
export function effect(
    fn: () => void,
    { namespace = "" } = {},
): Effect {
    if (!EffectQueues.has(namespace)) {
        EffectQueues.set(namespace, new Set());
    }
    const queue = EffectQueues.get(namespace);
    const effect = new Effect(
        fn,
        queue!.add.bind(queue),
        queue!.delete.bind(queue),
    );
    return effect;
}

/**
 * Runs all `Effect`s in a specified queue, clearing the queue in the process.
 *
 * @param namespace (optional) the identifier of a specific queue to flush.
 *        If not specified, then all queues are flushed.
 */
export function runEffects(namespace?: string): void {
    if (!namespace) {
        for (const key of EffectQueues.keys()) {
            const effects = Array.from(EffectQueues.get(key)!);
            EffectQueues.get(key)?.clear();
            for (const effect of effects) {
                effect.run();
            }
        }
    } else {
        const effects = Array.from(EffectQueues.get(namespace) ?? []);
        EffectQueues.get(namespace)?.clear();
        for (const effect of effects) {
            effect.run();
        }
    }
}

/**
 * Disposes `Effect`'s in a specified queue, clearing the queue in the process.
 *
 * @param namespace (optional) the identifier of a specific queue to dispose.
 *        If not specified, then all queues are flushed.
 */
export function disposeEffects(namespace?: string): void {
    if (!namespace) {
        for (const key of EffectQueues.keys()) {
            const effects = Array.from(EffectQueues.get(key)!);
            EffectQueues.get(key)?.clear();
            for (const effect of effects) {
                effect[Symbol.dispose]();
            }
        }
    } else {
        const effects = Array.from(EffectQueues.get(namespace) ?? []);
        EffectQueues.get(namespace)?.clear();
        for (const effect of effects) {
            effect[Symbol.dispose]();
        }
    }
}

/**
 * A function to run within an `effect` or `computed` function that accesses
 * a `Signal` value, but without creating a dependency link to values accessed
 * within `untracked`
 *
 * NOTE: this is not recommended in general; accessing `Signal` values in an
 * `untracked` fashion can lead to unexpected behaviors. `untracked` is only
 * safe to use if the accessed value is not used in producing a final value
 * (such as in logging use cases)
 */
export function untracked<T>(fn: () => T): T {
    return asActiveConsumer(undefined, fn);
}
